Cose da fare:

1. Calcolare il numero di istanze per ogni tipo:
    CVRP (Attualmente tutte)
    AVRP (Attualmente 0) (Funziona l'algoritmo scritto da noi su istanze del genere?)
    Quante istanze con meno di 50 nodi ci sono? Small
    Quante istanze con num nodi compreso tra 50 e 100 ci sono? Mid-Small
    Quante istanze con num nodi compreso tra 100 e 250 ci sono? Mid
    Quante istanze con num nodi compreso tra 250 e 500 ci sono? Mid-Large
    Quante istanze con num nodi compreso tra 500 e 1000 ci sono? Large
    Quante istanze sopra i 1000 nodi ci sono? Very Large
#################################################################################

2. Su alcune istanze, CW ci viene minore del costo ottimo.
    2.1 Abbiamo sbagliato qualcosa?
    2.2 Il costo ottimo Ã¨ sbagliato?

    Lista delle istanze con CW(Andrea e Alessia) minore del costo ottimo:
    - P-n22-k8.vrp
    - P-n55-k15.vrp




Problemi sweep opt-3 Alessia:

    while improved:
            improved = False
            for (i, j, k) in itertools.combinations(range(1, num_nodes - 1), 3):
                # Assicurarsi che i, j, k non siano consecutivi
                if j - i > 1 and k - j > 1:
                    print(f"3-opt swap: {i} {j} {k}")
                    new_routes = apply_3opt(best_route, i, j, k)     # apply_3opt(route, i, j, k)
                    for new_route in new_routes:
                        new_distance = calculate_total_distance(new_route)
                        if new_distance < best_distance:
                            best_route = new_route
                            best_distance = new_distance
                            improved = True
                            print(f"local best root {best_route}")


    while improved:
            improved = False
            for i in range(1, num_nodes - 3):
                for j in range(i + 1, num_nodes - 2):
                    for k in range(j + 1, num_nodes - 1):
                        if not j - i > 1 and not k - j > 1:
                            continue

                        print(f"3-opt swap: {i} {j} {k}")
                        new_routes = apply_3opt(best_route, i, j, k)
                        for new_route in new_routes:
                            new_distance = calculate_total_distance(new_route)
                            if new_distance < best_distance:
                                best_route = new_route
                                best_distance = new_distance
                                improved = True
                                print(f"local best root {best_route}")
                        if improved:
                            break
                    if improved:
                        break
                if improved:
                    break
